Java ADT Benchmark (nanoTime).
Warmup ops: 15000, Measure ops: 60000, Trials: 7


Sanity checks: OK


== Stack: ArrayListStack ==
  Workload1 bulk push+pop                 median:      15.99 ns/op   checksum: 449985000
  Workload2 mixed steady-state            median:      60.32 ns/op   checksum: -1055495428


== Stack: DLinkedListStack ==
  Workload1 bulk push+pop                 median:      30.05 ns/op   checksum: 449985000
  Workload2 mixed steady-state            median:     156.28 ns/op   checksum: -1055495428


== Queue: ArrayListQueue ==
  Workload1 bulk enq+deq                  median:      20.44 ns/op   checksum: 449985000
  Workload2 mixed steady-state            median:      53.77 ns/op   checksum: 8738648310


== Queue: DLinkedListQueue ==
  Workload1 bulk enq+deq                  median:      21.36 ns/op   checksum: 449985000
  Workload2 mixed steady-state            median:     158.40 ns/op   checksum: 8738648310


== PriorityQueue: SortedArrayListPQ ==
  Workload1 bulk enq+deq (uniform priorities)  median:   45637.02 ns/op   checksum: 449985000
  Workload2 mixed steady-state (uniform priorities)  median:   75119.15 ns/op   checksum: -101944034770
  Workload3 skewed priorities (bulk)      median:  148489.21 ns/op   checksum: 449985000


== PriorityQueue: SortedDLinkedListPQ ==
  Workload1 bulk enq+deq (uniform priorities)  median:   79919.09 ns/op   checksum: 449779852
  Workload2 mixed steady-state (uniform priorities)  median:   57730.49 ns/op   checksum: -101944034770
  Workload3 skewed priorities (bulk)      median:   72668.71 ns/op   checksum: 449935616


== PriorityQueue: BinaryHeapPQ ==
  Workload1 bulk enq+deq (uniform priorities)  median:     169.16 ns/op   checksum: 449985000
  Workload2 mixed steady-state (uniform priorities)  median:     116.59 ns/op   checksum: -106337492798
  Workload3 skewed priorities (bulk)      median:      99.26 ns/op   checksum: 449985000








Explain differences using Big-O and real machine effects:


When using Big-O, all of the stack and queue implementations have a constant time meaning that when the input size gets larger, 
the implementations remain constant. Push, pop, enqueue, and dequeue are all constant timed methods as well. Because of this, 
most of the changes come from the hardware of the computer and or the real machine effects. Array-based structures are typically 
faster because they are stored right next to one another in memory making it easier for the computer to grab memory faster.
On the other hand, Linked lists store their data in different places in memory and connect them with pointers so the computer has 
to keep jumping around taking more time. In simpler operations they both perform similarly, but when they are forced to do many processes 
at once, the arraylists are faster. 


PriorityQueue: explain why the heap typically dominates for large N and what patterns can make sted structures look better or worse.

For larger amounts of data the heap is faster because it does much less work per operation. Furthermore, when you are wanting to insert 
something, shifting elements in a list in order to make space takes a lot of time (especially if there is a large number of elements). 
Because of this the heap only stores enough to find the smallest item quickly, meaning it doesn't take a lot of steps to move shift 
elements around. Additionally, heaps are stored in an array, allowing computers to access it faster.